# PROJECTIONS SPACIALES

Loading

```{r}
# # Fonction pour encoder et reconstruire les couches raster
# encode_substrat_in_raster <- function(raster_path) {
#   # Charger le raster
#   environment_data <- raster(raster_path)
#   
#   # Vérifier et sélectionner la couche "substrat"
#   layer_names <- names(environment_data)
#   substrat_layer_index <- which(layer_names == "substrat")
#   
#   # Si la couche "substrat" existe, procéder à l'encodage
#   if (length(substrat_layer_index) > 0) {
#     substrat_layer <- environment_data[[substrat_layer_index]]
#     substrat_factor <- as.factor(substrat_layer)
#     substrat_df <- as.data.frame(substrat_factor, xy = TRUE)  
#     names(substrat_df) <- c("x", "y", "substrat")
#   
#     # Appliquer l'encodage one-hot
#     substrat_encoded <- fastDummies::dummy_cols(substrat_df, select_columns = "substrat", remove_first_dummy = TRUE, remove_selected_columns = TRUE)
#     
#     # Reconstruire le raster pour chaque couche one-hot
#     new_layers <- list()
#     for (col in names(substrat_encoded)[!names(substrat_encoded) %in% c("x", "y")]) {
#       new_layer <- raster(environment_data, template=environment_data)
#       values(new_layer) <- substrat_encoded[[col]]
#       new_layers[[col]] <- new_layer
#     }
#     
#     # Combinez les nouvelles couches avec les autres couches non-modifiées du raster original
#     new_stack <- stack(new_layers, environment_data[-substrat_layer_index])
#     return(new_stack)
#   } else {
#     # Si pas de couche "substrat", retourner le raster original sans modification
#     return(environment_data)
#   }
# }
# 
# # Initialiser une liste pour stocker les données de chaque année
# environment_data_list <- list()

for(year in 1993:2021) {
  file_path <- sprintf("../Donnees/Environment_%04d.gri", year)
  encoded_data <- stack(file_path)
  environment_data_list[[as.character(year)]] <- encoded_data
}

# Charger les variables du modèle
model_features <- readRDS("../Models/delta_model.rds")$features

# Sélectionner les variables nécessaires et nettoyer les données
cleaned_data_list <- lapply(environment_data_list, function(data) {
  # Convertir le raster en data frame
  data_df <- as.data.frame(data, xy = TRUE)
  
  data_df <- fastDummies::dummy_cols(data_df,
                               select_columns = "substrat",
                               remove_first_dummy = FALSE,
                               remove_selected_columns = TRUE
                               )

  # Sélectionner uniquement les colonnes nécessaires pour le modèle
  selected_data <- data_df[, c("x", "y", model_features)]

  # Enlever les lignes contenant des valeurs NA
  clean_data <- na.omit(selected_data)
  
  return(clean_data)
})

## Charger le modèle
delta_model <- readRDS("../Models/delta_model.rds")

# Faire des prédictions pour chaque tableau
predictions_list <- lapply(cleaned_data_list, function(data) {
  # Création d'un dataset sans les colonnes x, y pour la prédiction
  prediction_data <- select(data, -x, -y)
  
  # Faire des prédictions
  predicted_density <- predict_delta_model(delta_model, newdata = prediction_data)
  
  # Ajouter les prédictions comme une nouvelle colonne au dataset original
  data$predicted_density <- predicted_density
  return(data)
})
```

Preparing the data for the model

```{r}
# Charger les variables du modèle
model_features <- readRDS("../Models/delta_model.rds")$features

# Sélectionner les variables nécessaires et nettoyer les données
library(dplyr)

cleaned_data_list <- lapply(environment_data_list, function(data) {
  # Convertir le raster en data frame
  data_df <- as.data.frame(data, xy = TRUE)

  # Sélectionner uniquement les colonnes nécessaires pour le modèle
  selected_data <- data_df[, c("x", "y", model_features)]

  # Enlever les lignes contenant des valeurs NA dans les colonnes qui   intéressent le modèle
  clean_data <- na.omit(selected_data)
  
  return(clean_data)
})
```

Make predictions

```{r}
## Charger le modèle
delta_model <- readRDS("../Models/delta_model.rds")

# Faire des prédictions pour chaque tableau
predictions_list <- lapply(cleaned_data_list, function(data) {
  # Création d'un dataset sans les colonnes x, y pour la prédiction
  prediction_data <- data %>%
    select(-x, -y)  # Utilisation de select pour retirer x et y
  
  # Faire des prédictions
  predicted_density <- predict_delta_model(
    delta_model,
    newdata = prediction_data
    )
  
  # Ajouter les prédictions comme une nouvelle colonne au dataset original
  data$predicted_density <- predicted_density
  return(data)
})
```

Projection

```{r}
library(ggplot2)

# Exemple pour une année spécifique, par exemple 2021
data_to_plot <- predictions_list[["2003"]]

ggplot(data_to_plot, aes(x = x, y = y, fill = predicted_density)) +
  geom_tile() + 
  scale_fill_gradient(low = "blue", high = "red", name = "Fish Density") +
  coord_fixed() +
  labs(title = "Fish Density Map 2003", x = "Longitude", y = "Latitude") +
  theme_minimal()
```

Rescaling to get more small values

```{r}
ggplot(data_to_plot, aes(x = x, y = y, fill = predicted_density)) +
  geom_tile() + 
  scale_fill_gradientn(
    colors = c("blue", "cyan", "green", "yellow", "red"),
    values = scales::rescale(c(0, 0.1, 0.2, 0.5, 1)),
    limits = c(min(data_to_plot$predicted_density, na.rm = TRUE), max(data_to_plot$predicted_density, na.rm = TRUE)),
    name = "Fish Density"
  ) +
  coord_fixed() +
  labs(title = "Fish Density Map 2021", x = "Longitude", y = "Latitude") +
  theme_minimal()
```

3rd plot

```{r}
# Calcul des quantiles pour définir les points de rupture de l'échelle de couleurs
# quantile_breaks <- function(data, probs = c(0, 0.25, 0.5, 0.75, 1)) {
#   quantiles <- quantile(data, probs = probs, na.rm = TRUE)
#   return(quantiles)
# }
# 
# # Définir la palette de couleurs pour les quantiles
# quantile_colours <- c("white", "skyblue", "blue", "darkblue", "navy")

for(year in 1993:2021){
  data_to_plot <- predictions_list[[as.character(year)]]
  
  # Calculer le maximum de la densité prédite pour l'année
  max_density <- max(data_to_plot$predicted_density, na.rm = TRUE)

  # Créer les groupes basés sur les quartiles définis linéairement
  data_to_plot$density_group <- cut(
    data_to_plot$predicted_density,
    breaks = c(0, 1e-5, max_density/4, max_density/2, 3*max_density/4, max_density),
    include.lowest = TRUE,
    labels = c(
      "0",
      paste0("1 Quart [>0, ",max_density/4,"]"),
      paste0("2 Quart [",max_density/4,",",max_density/2,"]"),
      paste0("3 Quart [",max_density/2,",",3*max_density/4,"]"),
      paste0("4 Quart [",3*max_density/4,",",max_density,"]")
              )
  )

  # Assigner une couleur à chaque groupe de densité
  colors <- c("white", "skyblue", "darkcyan","blue", "darkblue")

  dernier_plot <- ggplot(data_to_plot, aes(x = x, y = y, fill = density_group)) +
    geom_tile() +
    scale_fill_manual(values = colors) +
    coord_fixed(ratio = 1) +
    labs(
      title = paste0("Fish Density Map ", year),
      fill = "Fish Density",
      x = "Longitude",
      y = "Latitude"
    ) +
    theme_minimal() +
    theme(
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10),
      plot.title = element_text(size = 14, face = "bold"),
      legend.key.size = unit(1.5, "lines"),
      legend.position = "right"
    )

  # Sauvegarde du plot
  ggsave(paste0("../Outputs/fish_density_map_", year, ".png"), plot = dernier_plot, width = 10, height = 8, dpi = 1200)
}
```
