# PROJECTIONS SPACIALES

Loading

```{r}
# # Fonction pour encoder et reconstruire les couches raster
# encode_substrat_in_raster <- function(raster_path) {
#   # Charger le raster
#   environment_data <- raster(raster_path)
#   
#   # Vérifier et sélectionner la couche "substrat"
#   layer_names <- names(environment_data)
#   substrat_layer_index <- which(layer_names == "substrat")
#   
#   # Si la couche "substrat" existe, procéder à l'encodage
#   if (length(substrat_layer_index) > 0) {
#     substrat_layer <- environment_data[[substrat_layer_index]]
#     substrat_factor <- as.factor(substrat_layer)
#     substrat_df <- as.data.frame(substrat_factor, xy = TRUE)  
#     names(substrat_df) <- c("x", "y", "substrat")
#   
#     # Appliquer l'encodage one-hot
#     substrat_encoded <- fastDummies::dummy_cols(substrat_df, select_columns = "substrat", remove_first_dummy = TRUE, remove_selected_columns = TRUE)
#     
#     # Reconstruire le raster pour chaque couche one-hot
#     new_layers <- list()
#     for (col in names(substrat_encoded)[!names(substrat_encoded) %in% c("x", "y")]) {
#       new_layer <- raster(environment_data, template=environment_data)
#       values(new_layer) <- substrat_encoded[[col]]
#       new_layers[[col]] <- new_layer
#     }
#     
#     # Combinez les nouvelles couches avec les autres couches non-modifiées du raster original
#     new_stack <- stack(new_layers, environment_data[-substrat_layer_index])
#     return(new_stack)
#   } else {
#     # Si pas de couche "substrat", retourner le raster original sans modification
#     return(environment_data)
#   }
# }
# 
# # Initialiser une liste pour stocker les données de chaque année
# environment_data_list <- list()

for(year in 1993:2021) {
  file_path <- sprintf("../Donnees/Environment_%04d.gri", year)
  encoded_data <- stack(file_path)
  environment_data_list[[as.character(year)]] <- encoded_data
}

# Charger les variables du modèle
model_features <- readRDS("../Models/delta_model.rds")$features

# Sélectionner les variables nécessaires et nettoyer les données
cleaned_data_list <- lapply(environment_data_list, function(data) {
  # Convertir le raster en data frame
  data_df <- as.data.frame(data, xy = TRUE)
  
  data_df <- fastDummies::dummy_cols(data_df,
                               select_columns = "substrat",
                               remove_first_dummy = FALSE,
                               remove_selected_columns = TRUE
                               )

  # Sélectionner uniquement les colonnes nécessaires pour le modèle
  selected_data <- data_df[, c("x", "y", model_features)]

  # Enlever les lignes contenant des valeurs NA
  clean_data <- na.omit(selected_data)
  
  return(clean_data)
})

## Charger le modèle
delta_model <- readRDS("../Models/delta_model.rds")

# Faire des prédictions pour chaque tableau
predictions_list <- lapply(cleaned_data_list, function(data) {
  # Création d'un dataset sans les colonnes x, y pour la prédiction
  prediction_data <- select(data, -x, -y)
  
  # Faire des prédictions
  predicted_density <- predict_delta_model(delta_model, newdata = prediction_data)
  
  # Ajouter les prédictions comme une nouvelle colonne au dataset original
  data$predicted_density <- predicted_density
  return(data)
})
```

Projection

```{r}
library(ggplot2)

# Exemple pour une année spécifique, par exemple 2021
data_to_plot <- predictions_list[["2003"]]

ggplot(data_to_plot, aes(x = x, y = y, fill = predicted_density)) +
  geom_tile() + 
  scale_fill_gradient(low = "blue", high = "red", name = "Fish Density") +
  coord_fixed() +
  labs(title = "Fish Density Map 2003", x = "Longitude", y = "Latitude") +
  theme_minimal()
```

Rescaling to get more small values

```{r}
ggplot(data_to_plot, aes(x = x, y = y, fill = predicted_density)) +
  geom_tile() + 
  scale_fill_gradientn(
    colors = c("blue", "cyan", "green", "yellow", "red"),
    values = scales::rescale(c(0, 0.1, 0.2, 0.5, 1)),
    limits = c(min(data_to_plot$predicted_density, na.rm = TRUE), max(data_to_plot$predicted_density, na.rm = TRUE)),
    name = "Fish Density"
  ) +
  coord_fixed() +
  labs(title = "Fish Density Map 2021", x = "Longitude", y = "Latitude") +
  theme_minimal()
```

3rd plot

```{r}
# Calcul des quantiles pour définir les points de rupture de l'échelle de couleurs
# quantile_breaks <- function(data, probs = c(0, 0.25, 0.5, 0.75, 1)) {
#   quantiles <- quantile(data, probs = probs, na.rm = TRUE)
#   return(quantiles)
# }
# 
# # Définir la palette de couleurs pour les quantiles
# quantile_colours <- c("white", "skyblue", "blue", "darkblue", "navy")

for(year in 1993:2021){
  data_to_plot <- predictions_list[[as.character(year)]]
  
  # Calculer le maximum de la densité prédite pour l'année
  max_density <- max(data_to_plot$predicted_density, na.rm = TRUE)

  # Créer les groupes basés sur les quartiles définis linéairement
  data_to_plot$density_group <- cut(
    data_to_plot$predicted_density,
    breaks = c(0, 1e-5, max_density/4, max_density/2, 3*max_density/4, max_density),
    include.lowest = TRUE,
    labels = c(
      "0",
      paste0("1 Quart [>0, ",max_density/4,"]"),
      paste0("2 Quart [",max_density/4,",",max_density/2,"]"),
      paste0("3 Quart [",max_density/2,",",3*max_density/4,"]"),
      paste0("4 Quart [",3*max_density/4,",",max_density,"]")
              )
  )

  # Assigner une couleur à chaque groupe de densité
  colors <- c("white", "skyblue", "darkcyan","blue", "darkblue")

  dernier_plot <- ggplot(data_to_plot, aes(x = x, y = y, fill = density_group)) +
    geom_tile() +
    scale_fill_manual(values = colors) +
    coord_fixed(ratio = 1) +
    labs(
      title = paste0("Fish Density Map ", year),
      fill = "Fish Density",
      x = "Longitude",
      y = "Latitude"
    ) +
    theme_minimal() +
    theme(
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10),
      plot.title = element_text(size = 14, face = "bold"),
      legend.key.size = unit(1.5, "lines"),
      legend.position = "right"
    )

  # Sauvegarde du plot
  ggsave(paste0("../Outputs/fish_density_map_", year, ".png"), plot = dernier_plot, width = 10, height = 8, dpi = 1200)
}
```

Mean Density

```{r}
# Combiner tous les datasets de prédictions en un seul dataframe
all_predictions <- do.call(rbind, predictions_list)

# Calculer la moyenne des densités prédites pour chaque position
average_density <- all_predictions %>%
  group_by(x, y) %>%
  summarise(average_density = mean(predicted_density, na.rm = TRUE))

mean_max_density <- max(average_density$average_density, na.rm = TRUE)

# Créer les groupes basés sur les quartiles
average_density$density_group <- cut(
  average_density$average_density,
  breaks = c(0, 1e-5, mean_max_density/4, mean_max_density/2, 3*mean_max_density/4, mean_max_density),
  include.lowest = TRUE,
  labels = c(
      "0",
      paste0("1 Quart [>0, ",mean_max_density/4,"]"),
      paste0("2 Quart [",mean_max_density/4,",",mean_max_density/2,"]"),
      paste0("3 Quart [",mean_max_density/2,",",3*mean_max_density/4,"]"),
      paste0("4 Quart [",3*mean_max_density/4,",",mean_max_density,"]")
              )
)

# Assigner une couleur à chaque groupe de densité
colors <- c("white", "skyblue", "darkcyan", "blue", "darkblue")


# Visualiser la moyenne de la densité sur une carte
ggplot(average_density, aes(x = x, y = y, fill = density_group)) +
  geom_tile() +
  scale_fill_manual(values = colors) +
  coord_fixed(ratio = 1) +
  labs(
    title = "Average Fish Density Map by Quartiles",
    fill = "Fish Density Group",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    plot.title = element_text(size = 14, face = "bold"),
    legend.key.size = unit(1.5, "lines"),
    legend.position = "right"
  )

# Sauvegarder le graphique
ggsave("../Outputs/average_fish_density_map_quartiles.png", width = 10, height = 8, dpi = 1200)
```

#### Carte recurrence

```{r}
percentiles <- sapply(predictions_list, function(data) {
  quantile(data$predicted_density, probs = 0.9, na.rm = TRUE)
})
```

Identifications of points (x,y) higher than 90 percentile

```{r}
library(dplyr)

# Création d'un dataframe unique pour tous les points avec l'année
all_data <- do.call(rbind, lapply(names(predictions_list), function(year) {
  cbind(predictions_list[[year]], year = year)
}))

# Ajout de la colonne percentile pour chaque observation
all_data <- all_data %>%
  mutate(above_percentile = predicted_density > percentiles[paste0(year,".90%")])
```

Computing the frequency for each x,y

```{r}
# Assurez-vous que vous avez calculé n_years comme le nombre d'années distinctes
n_years <- length(unique(all_data$year))

# Convertir les valeurs logiques en numériques pour le calcul
all_data$above_percentile <- as.numeric(all_data$above_percentile)

recurrence_data <- all_data %>%
  group_by(x, y) %>%
  summarise(recurrence = sum(above_percentile) / n_years) %>%
  ungroup()
```

Visualization

```{r}
# Utilisation de geom_raster au lieu de geom_tile pour une meilleure résolution
ggplot(recurrence_data, aes(x = x, y = y, fill = recurrence)) +
  geom_raster(interpolate = TRUE) + 
  scale_fill_gradient(low = "cyan", high = "darkblue", name = "Récurrence") +
  labs(title = "Carte de récurrence de la densité de poissons",
       subtitle = "Fréquence des points au-dessus du 90e percentile de la densité",
       x = "Longitude",
       y = "Latitude") +
  theme_minimal() +
  theme(legend.position = "right")

# Enregistrement avec une résolution plus élevée
ggsave("carte_recurrence.png", width = 10, height = 8, dpi = 1000)

```

```{r}
# Charger les shapefiles avec sf
shapefile_path <- "../Donnees/data_carto/commune_francemetro_2021.shp"  # Remplacez par le chemin réel vers votre fichier .shp
fond_carte <- st_read(shapefile_path)

palette <- colorRampPalette(brewer.pal(9, "YlOrRd"))(100)

# Définir les limites pour cibler le Golfe de Gascogne
# Remplacez ces valeurs par les limites qui correspondent à votre zone d'étude
xlim <- c(-5, 0)  # Longitudes minimale et maximale
ylim <- c(44, 48)  # Latitudes minimale et maximale

ggplot() +
  geom_sf(data = fond_carte, fill = "lightgray", color = "gray") +
  geom_raster(data = recurrence_data, aes(x = x, y = y, fill = recurrence), interpolate = TRUE) +
  scale_fill_gradientn(colours = palette, name = "Récurrence") +
  labs(title = "Carte de récurrence de la densité de poissons",
       subtitle = "Fréquence des points au-dessus du 90e percentile de la densité",
       x = "Longitude",
       y = "Latitude") +
  coord_sf(xlim = xlim, ylim = ylim, expand = FALSE) +  # Appliquer les limites définies
  theme_minimal() +
  theme(legend.position = "right")

# Enregistrement avec une résolution plus élevée
ggsave("../Outputs/carte_recurrence_golfe_gascogne.png", width = 10, height = 8, dpi = 300)

```
